// {/* <div>
// <h2>

// level up: 
// example one: what is the time complexity? you have a sum of the array at each index then for each element you're mulitplying that so its o(n)? why? 

// two: loop in a loop that expotential!! 
// three: careful, two arary so they multiple so thats n times m 

// four is the the same
//     what is equivalent ot O(N)
//     o(2n)
// what are all the terms for classifciation? what is time complexity? what is space complexity?

// what is space? why do vast majority of data structures hav ea space complexity of O (N)?

// what is O (n)?

// what is o1? 
// how do you describe the nature of space taken up in a computer and the size of data? 



// What is factorial complexity? 
// what is is ti called hwen every solution must be correctly outputed to be determined? what is an example of this? 

// if it takes 1 second for 100 items? how long? 


// what is power of 2 complexity? (O(2^N))
// what is power of two? how does input affect? what is a fibonacci? 

// what is log linear complexity? 
// how does input grow? what are sorts for this? merge? time? heap? if it takes 1 item 1 second, 100 items? 300 seconds
// what are runtimes? 
// what is a multi part algo? how does it deal with multiple data sets? do we add or multiply runtimes? when? 
// the more data you ahve, the longer it iwll take to run the log 

// why add them if its a do this then wehn done do that

// how is runtime influenced by sieze of arr and arr  how do we big o represent this or how do we abstrac?

// when do we multiply? 
// why is it when we do this for each time you do that then mulitply? 

// why do we multiplate when we iterate through arr b for every time in arr A 

// why multiple when we iterate through a for every item in a 

// so is it arr a times arr a or arr squared?
// what do we do with the b  array? do we add that? what is the abstraciton? 

// third example of this multiply runtimes 


// what are dropping non dominant terms? 
// --once youre in the quadrtic it sover


// what is quadratic complexity? 
// O(N^2) 

// how is input affected? is it efficent? examples? why quick, buble, and insertion? 
// nested loops? 

// 1 item = 1 second
// 100 items = ? 

// how is looping through 2 d array? how is this code doing that? 


// what is logarithimc complexity? 
// O(log(N))
// hwo does input growth affect process time? 
// why half? 
// are they efficient? 
// what are examples? 
// why binary search? 
// why a guess teh number? 
// you are taking things out fo the equation-- its like an algorithim where you are taking away from the total even when you guess wrong

// if it takes 1 second for 1 item,s how long for 100 items? 

// it processes increases half of what it was previously used?
// 16 million to 1 in 24 iterations


// what are droping constants? 
// does the amount of code matter for the same data? 
// what is the point of big o in realtion to here? 
// in big o does it matter if they arent the same? 
// why does it matter how it scales? 
// what about the data is different? nothing so it scales the same
// 150N is the same as N why? 
// its all scaling the same 


// what is linear complexity? 
// O(N)
// how does input effect the pace? 
// is this considered efficeint? 
// examples? 
// why searching an array? 
// why on all ements? 
// what about inserting single things into existing data? 
// is downloading? 

// if it takes 1 second to process 100 items takes how long? 

// {/* what is constnat complexity? 
// 0(1)
// how does the input matter? 
// will it take the same time? 

// what are some expamples? 
// why add or remove single elements? 
// why on one digit? 

// if it takes item 1 second to process, how long would 100 items? 

// what's a code exmpale ?

// what is big o? 
// how do we describe efficiency of an algorithim? 
// how many cpu cycles does it take vs actual amount of time it takes vs how many iterations? 
// what does big o meausre? does it account of r small picture or unit of measurement? what metric is it concerned with? how is it for detail? 
// what is a runtime? 
// how do we judge exactly what makes an lgorithm faster slower and more or less space efficient than a similar algo? how does it improve our decisions? 

// what is the best case version? 
// is it lucky to get omega? 

// what is representation for expectated case? what symbol? 


// what are alogirithms
// how do we achieve a goal or solve? show oven 


// Emre lecture

// what is an algo? See chart --Recipe

//  why a series of steps? Because there is mulitple ways to do it. 
 
//  how do we use big o? on it? measure the efficency of algorithim
//  what does it measure? Time complexity, run times and space compelxity. 

// what makes an algo inefficient? Nested loop, having to check all the items every time you want to do one thing over nad over 

// does a loop help? 

// worst caase scenario while making a pie? checking oven? 

// what are different types of Big O? o of 1, o of n, look at all these different kind of variations 

// what is most efficeint? o of 1 what amkes o1 the most? becuase the amount of data doesnt matter for how long it runs. 
// what about o log n ? 

// what happens when you increase in put? that's waht we are figuring out. Does it get more time, how much does longer does it take. 

// what is cracking the code? 

// what does big o concern itsle with? time compleixty. 

// what is the big o? 

// what is the big o for the function? 
// how long does a function to run? 
// what are measuring? how long does it take? how much spacae does it take? 

// why does big o matter? what do we want tos ay about our code 

// what is the worst case scenario? 

// what is the best case scenario expressed as? omega. The best case scenario you know for finding a random number between 1 and 100, the best case scenario for the code is obviously the first time but that's not super helpful. well we coudlg et it the first time. No we don't wanta that, we want ot know if everything hits the fan, does our code create a strucutre that will take up as little time as possible to deliver the data we want. 

// what is expected case? what are sorting and search algo? 

// are mergre sort data sort out of date? are they good way of testing ability of engineer? 

// are there libaries that do this stuff? is search writing normal for early engineer? 

// what is worst case? 

// what is constnat complexity? what is an example? how many input, does it matter? 
// what is a queue? first in first out? why is it 01? is it always the same ? 
// what about stack? top? 
// what is the time it takes n to do? 

// whats an example? 
// //fill two arrays 
// tinyArray = Array(10).fill(0)
// largeArray = Array(100000000).fill(0)
// //find fifth element 
// findFifthElementOfArray(tinyArray)
// findFifthElementOfArray(largeArray)

// function findFifthElementOfArray(arr) {
// 	return arr[4]
// } */}
// does it matter how large array is? 

// what is o of n complexity? as it grows, the complexity grows with it 
// what happens to size of time as input goes? 

// what happens to time as input increases? 

// what are examples? inserting some alphatbetically. finding a random number between index zero and index length . downloading something.  is it efficent? does it increase? what is a whiteboard? 

// / Creates this array: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
// tinyArray = Array.from(Array(10).keys())
// // Creates a very large array starting with: [0, 1, 2, 3 ...]
// largeArray = Array.from(Array(100000000).keys())

// findRandomNumberInArray(tinyArray)
// findRandomNumberInArray(largeArray)

// function findRandomNumberInArray(arr) {
//     //create random number based on the length of array so the more data, the more this line can use. 
//   const randomNum = Math.floor(Math.random() * arr.length)
//   //loop through the data to find the random number --again wrost case. 2 vs 100
//   for (let i = 0; i < arr.length; i++) {
//     if (randomNum === arr[i]) return arr[i]
//   }
// }

// how do we show it? what do two arrays show us? what is worst case scenario? what if random number is 10 million on large array as opposed to just 2 numbers? 

// when we find smallest or largest number, which is slower? we loops through it and have 2 conditions or 2 for reach methods? which is slower? 
// 2 loops with 1 line each or 1 loop with 2 lines? 

// why do both have same efficency? why do htye scale the same way? 
// do they scale in the same way? yes. they are still looping through the data twice in the for reach function. yes its going through the data N twice so 2N so yes, this would take longer than going through it once but again, the time complexity is incresing as the data goes up so big picture, while the stop watch may show the same, the way the time is increasgin is the same. So we can drop the constant. 

// what is logathrimithic? as the data grows, teh amount of time the increase of time is getting smaller. by half. pick a number between one and ten. lets say i pick the number 7 ...

// is this realisitic? is this like serach algo? can anyone think of exmaple? is it a guess a number game? what ist he main feature of this? 

// what does the code look like?

// const n = 16777216

// log(n)

// {/* function log(n) {
//   let j = 0
//   //loop through i starting at n and keep dividing as long as its greater than this and j keep trakc for each loops 
//   for(let i = n; i >.999; i /= 2) {
//     console.log(
// 			`The result of iterion ${j} is ${i}`
// 		)
//     j++
//   }
// } */}

// increment j -- with each iteration we reduce it by half? 

// half and half and half


// what is o n squared it grows expontentially

// is it efficent? no 

// what is the processing time effects? 

// what would you have to do to 2 loops for it to be quadratic? how would you nest loops? would it be quadratic? should you run loops within loops? if you don't know how many times, it will be quadratic? 

// const fakeTwoDimensionArray = [[1], [2], [3], [4], [5, 6, 7]]

// logArray(fakeTwoDimensionArray)

// {/* function logArray(arr) {
//     loop trhough this data
//   for(let i = 0; i < arr.length; i++){
//     console.log(arr[i])
//     // at each iteration loop again 
//     for(let j = 0; j < arr.length; j++){
//       console.log("i: ", arr[i], "j: ", arr[j])
//     }
//   }
// } */}

// what is nested? array? within array? two loops? that is increasing complexity  

// IS CODE GOOD? You good, code? 

// what is run time for this? is it bad if the nested has only one value? 

// but what if its not? 

// what is the larger input mean? 
// can you do it in sperate loops and do seperate function? what would an alternative be? 

// can you put a limit on it? 

// --

// {/* const fakeTwoDimensionArray = [1, 2, 3, 4, 5];

// logArray(fakeTwoDimensionArray)

// function logArray(arr) {
//   for(let i = 0; i < arr.length; i++){
//     console.log(arr[i])
//     for(let j = 0; j < arr.length; j++){
//       console.log("i: ", arr[i], "j: ", arr[j])
//     }
//   }
//   //dont worry about this 
//   for(let i = 0; i < arr.length; i++){
//     console.log(arr[i])
//   }
// } */}

// {/* 
// function nLog(n) {
//   let i = 1
//   // Begin outer loop: Iterate from 0 to n-1
//   for(let j = 0; j < n; j++){
//     // Begin inner loop with a possibly incorrect condition (k > 0.999 will never be true for k starting at 0)
//     // Assuming the intent might have been different, this loop as is won't execute
//     // A correct condition would be necessary for actual execution
//     for(let k = 0; k > 0.999; i /= 2){
//       // Log the current iteration number (i) and the value of k
//       console.log(`The result of iteration ${i} is ${k}`)
//       // Increment i with each iteration - however, note that this increment
//       // and the for-loop's update expression (i /= 2) are likely not what was intended
//       // as they modify the loop counter in unusual ways for a typical loop
//       i++
//     }
//   }
// } */}


// what woudl you do? create a different strucutre -- strip arrays out -- make an object -- make it a single array and then loop -- 

// is code livign organism? 

// how do oyu balance best code with time and moeny? 



// how to calcualte big o? 

// do we keep non importnat terms? 

// what about this array? dropping non dominatn 
// what is the least sufficent area of a function? 

// what is a multi party algo? 
// does it deal with mulitple data sets? 
// how many times? 

// do we add or multiply the runtime? 

// when? 

// what does do this then wait then do that-- is that two notations? 
// arra a but arr b 

// what a is the big o? 

// first you loop array a then b 

// linear? o of n plus m so just o of n 

// when do oyu multiply? 
// do that for each time? 
// how do oyu read it? 

// READ THE CODE? 

// how do we mulitpy it? a squared 

// abstracted as n 2 

// how do we get squared? mulitply inputs 

// o of 1 plus o of 1 is o of 1 

// what are nested loops? 

// whats the complexity of your functions? 

// what si of o of n log n? what sorts use these? the input is unordered structre -- 

// what is the nested loop? -- what is a merge srot in ajavscript ? are there nested arrays? 
// what is o of 2 to the n -- what is the fibonacci number

// what is o n! -- what if memory runs out? how much memory does a browser have for scripts/ 

// o of n is most space complexity -- how memory going to take up? -- time is how much time to run? 
// what is big o helpful for? 

// can you level up? 

// what is big o? 

// whtie board: 

// number 2: 
// o log n? 



// level up and white board

// read code -- and then! o of n 


// </h2> */}
